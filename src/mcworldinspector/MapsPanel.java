
package mcworldinspector;

import java.awt.Component;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.table.AbstractTableModel;
import mcworldinspector.nbttree.NBTTreeModel;

/**
 *
 * @author matthias
 */
public class MapsPanel extends JPanel implements MCWorldInspector.InfoPanel {

    private final Model model = new Model();
    private World world;
    private WorldRenderer renderer;

    public MapsPanel() {
        initComponents();

        mapsTable.getSelectionModel().addListSelectionListener(l -> {
            final var selected = mapsTable.getSelectedRows();
            updateMapDisplay(selected);
            if(renderer == null)
                return;
            renderer.highlight(IntStream.of(selected)
                .mapToObj(model.maps::get)
                .flatMap(map -> {
                    final var x = map.getX();
                    final var z = map.getZ();
                    final var scale = map.getScale();
                    final var size = 128 << scale;
                    return Stream.of(new MapHighlightEntry(map,
                            x - size/2, z - size/2, size));
                }));
        });
    }

    @Override
    public JComponent getTabComponent() {
        return this;
    }

    @Override
    public void reset() {
        world = null;
        renderer = null;
        model.maps = Collections.emptyList();
        model.fireTableDataChanged();
        btnFindMapMarkers.setEnabled(false);
    }

    @Override
    public void setWorld(World world, WorldRenderer renderer) {
        this.world = world;
        this.renderer = renderer;
        model.maps = new ArrayList<>(world.getMaps().values());
        model.fireTableDataChanged();
        btnFindMapMarkers.setEnabled(true);
    }

    private void updateMapDisplay(int[] selected) {
        mapDisplay.setMap((selected.length == 1)
                ? model.maps.get(selected[0]) : null);
    }

    private void updateMapDisplay() {
        updateMapDisplay(mapsTable.getSelectedRows());
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.JScrollPane jScrollPane1 = new javax.swing.JScrollPane();
        mapsTable = new javax.swing.JTable();
        mapDisplay = new mcworldinspector.MCMapDisplay();
        btnFindMapMarkers = new javax.swing.JButton();

        mapsTable.setModel(model);
        jScrollPane1.setViewportView(mapsTable);

        btnFindMapMarkers.setText("Find map markers in chests");
        btnFindMapMarkers.setToolTipText("");
        btnFindMapMarkers.setEnabled(false);
        btnFindMapMarkers.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFindMapMarkersActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnFindMapMarkers, javax.swing.GroupLayout.DEFAULT_SIZE, 276, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(mapDisplay, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mapDisplay, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(btnFindMapMarkers)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void btnFindMapMarkersActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindMapMarkersActionPerformed
        if(world == null)
            return;
        world.chunks().parallel()
                .flatMap(Chunk::tileEntities)
                .flatMap(MCItem::getChestContent)
                .filter(MCItem.filterByID("minecraft:filled_map"))
                .forEach(i -> world.loadMapMarkers(i.tag));
        updateMapDisplay();
    }//GEN-LAST:event_btnFindMapMarkersActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnFindMapMarkers;
    private mcworldinspector.MCMapDisplay mapDisplay;
    private javax.swing.JTable mapsTable;
    // End of variables declaration//GEN-END:variables

    class Model extends AbstractTableModel {
        List<MCMap> maps = Collections.emptyList();

        @Override
        public int getRowCount() {
            return maps.size();
        }

        @Override
        public int getColumnCount() {
            return 4;
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            return columnIndex == 2 ? Byte.class : Integer.class;
        }

        @Override
        public String getColumnName(int column) {
            switch (column) {
                case 0: return "X";
                case 1: return "Z";
                case 2: return "scale";
                case 3: return "index";
                default: throw new AssertionError();
            }
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            MCMap map = maps.get(rowIndex);
            switch (columnIndex) {
                case 0: return map.getX();
                case 1: return map.getZ();
                case 2: return map.getScale();
                case 3: return map.getIndex();
                default:
                    throw new AssertionError();
            }
        }
    }

    static class MapHighlightEntry implements WorldRenderer.HighlightEntry {
        final MCMap map;
        final int x;
        final int z;
        final int size;

        public MapHighlightEntry(MCMap map, int x, int z, int size) {
            this.map = map;
            this.x = x;
            this.z = z;
            this.size = size;
        }

        @Override
        public int getX() {
            return x;
        }

        @Override
        public int getZ() {
            return z;
        }

        @Override
        public int getWidth() {
            return size;
        }

        @Override
        public int getHeight() {
            return size;
        }

        @Override
        public String toString() {
            return "Map " + map.getIndex() + " for <" + x + ", " + z +
                    "> to <" + (x + size) + ", " + (z + size) + '>';
        }

        @Override
        public void showDetailsFor(Component parent) {
            NBTTreeModel.displayNBT(parent, map.getNbt(), "Map " + map.getIndex());
        }
    }
}
